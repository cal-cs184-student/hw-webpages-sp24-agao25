<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 Mesh Edit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Grace Liu and Alex Gao</h2>
<h2 align="middle"><a href="https://cal-cs184-student.github.io/hw-webpages-sp24-agao25/">Homework Submission Webpage: https://cal-cs184-student.github.io/hw-webpages-sp24-agao25/</a></h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>
    YOUR RESPONSE GOES HERE - high level overview on what was implemeneted, what interesting things you have learned from completing this assignment
</p>
<br>


<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>


<b>
  Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.
</b>
<p>
    de Casteljau's algorithm relies on successive, recursive linear interpolation to obtain intermediate points until a final interpolated point is calculated. To evaluate Bezier curves, we wrote a method that utilizes a for loop to perform the linear interpolation between two points for that level of recursion. Each time "E" is pressed, the algorithm runs and the interpolation reduces the number of points by 1. For example, from the initial level with four control points, we'll move to the 2nd level with 3 interpolated points now. Once we reach one final point (a Bezier point), the algorithm is done. Then, a Bezier curve can be graphed from edge point to edge point with that Bezier point on the curve as well.
</p>
<br>

<b>
  Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.
</b>

<!-- Example of including a single figure -->
<div align="middle">
    <img src="../results/Task1_1.png" align="middle" width="50%">
    <figcaption>Own Bezier curve with 6 control points</figcaption>
</div>
<br>

<b>
  Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve as well.
</b>
<!-- Example of including multiple figures -->
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 0</figcaption>
      </td>
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 1</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 2</figcaption>
      </td>
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 3</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 4</figcaption>
      </td>
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Level 5</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>

<b>
  Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter \(t\) via mouse scrolling.
</b>
<div align="middle">
  <img src="../results/Part1/Part1_BezierCurveNewPointsDiffT.png" align="middle" width="50%">
</div>

<br>


<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
<b>
  Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.
</b>
<p>
    The de Casteljau algorithm extends to Bezier surfaces by performing the linear interpolation in multiple different directions over an array of control points. In this way, we can identify multiple Bezier curves in one direction each with a Bezier point, and then interpolate those points into a singular point on the surface. These surface points when connected will ultimately form a surface. We implemented this by first defining an evaluateStep called that can perform a single level of interpolation. Then, we defined a method called evaluate1D that given some control points, can finish the linear interpolation in one direction and return the single, final control point. Finally, we defined a method called evaluate that performs evaluate1D on an array of control points in one direction to return some Bezier curvees and then performs evaluate1D again in the perpendicular to return a singular surface point.
    
</p>
<br>

<b>
  Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
</b>
<div align="middle">
  <img src="../results/Part2/Part2.png" align="middle" width="50%">
</div>
<br>


<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

<b>
  Briefly explain how you implemented the area-weighted vertex normals.
</b>
<p>
    We implemented area-weighted vertex normals by first calling out the initial halfedge and defining an empty Vector3D to store the weighted normal vectors. Then, we use a do/while loop to iterate through all of the faces that contain the given vertex, weight each face's normal vector components with the face's area, and sum up each of the weighted normals. The normalization of this summed vector gives us the vector to be used in Phong shading.
</p>
<br>

<b>
  Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use <kbd>Q</kbd> to toggle default flat shading and Phong shading.
</b>

<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="../results/Part3/Part3_flatShading.png" align="middle" width="400px"/>
        <figcaption>Teapot shading with vertex normals</figcaption>
      </td>
      <td>
        <img src="images/your_file.png" align="middle" width="400px"/>
        <figcaption>Teapot shading without vertex normals</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>

<h3 align="middle">Part 4: Edge Flip</h3>
<b>
  Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    account for boundary edge case, define every item of the initial halfedge data structure. then draw the diagram, repoint everything, made sure to implement our items in a specific order so that nothing was changed before it was edited.
    
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Show screenshots of the teapot before and after some edge flips.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h3 align="middle">Part 5: Edge Split</h3>
<b>
  Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Show screenshots of a mesh before and after some edge splits. 
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    YOUR RESPONSE GOES HERE
    debugging averaging, did minus instead of plus oops
    Debugging task3 because Phong shading wasn't working right once we split and flip some edges, norm not being tracked right and instead calculated area/norm based off cross product of points
</p>
<br>


<b>
    If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.
</b>
<p>
    N/A
</p>
<br>


<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
<b>
  Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    If you have implemented any extra credit extensions, explain what you did and document how they work with screenshots.
</b>
<p>
    N/A
</p>
<br>

</body>
</html>
